package service

import (
	"comptes/internal/domain"
	"comptes/internal/errors"
	"comptes/internal/storage"
	"strings"
	"time"
)

// TransactionService handles transaction operations
type TransactionService struct {
	storage storage.Storage
}

// NewTransactionService creates a new transaction service
func NewTransactionService(storage storage.Storage) *TransactionService {
	return &TransactionService{
		storage: storage,
	}
}

// AddTransaction adds a new transaction
func (s *TransactionService) AddTransaction(transaction domain.Transaction) error {
	// Validate transaction
	if err := s.validateTransaction(transaction); err != nil {
		return err
	}

	// Get existing transactions
	transactions, err := s.storage.GetTransactions()
	if err != nil {
		return errors.StorageReadFailed("transactions", err)
	}

	// Add new transaction
	transactions = append(transactions, transaction)

	// Save back to storage
	if err := s.storage.SaveTransactions(transactions); err != nil {
		return errors.StorageWriteFailed("transactions", err)
	}

	return nil
}

// GetTransactions returns all transactions
func (s *TransactionService) GetTransactions() ([]domain.Transaction, error) {
	return s.storage.GetTransactions()
}

// GetAccountBalance calculates the current balance for an account
func (s *TransactionService) GetAccountBalance(accountID string) (float64, error) {
	// Verify account exists
	accounts, err := s.storage.GetAccounts()
	if err != nil {
		return 0, errors.StorageReadFailed("accounts", err)
	}

	// Find the account
	var accountFound bool
	for _, acc := range accounts {
		if acc.ID == accountID {
			accountFound = true
			break
		}
	}

	if !accountFound {
		return 0, errors.AccountNotFound(accountID)
	}

	// Delegate balance calculation to storage
	return s.storage.GetAccountBalance(accountID)
}

// validateTransaction validates a transaction
func (s *TransactionService) validateTransaction(transaction domain.Transaction) error {
	// Check if account exists
	accounts, err := s.storage.GetAccounts()
	if err != nil {
		return errors.StorageReadFailed("accounts", err)
	}

	accountExists := false
	for _, account := range accounts {
		if account.ID == transaction.Account {
			accountExists = true
			break
		}
	}

	if !accountExists {
		return errors.AccountNotFound(transaction.Account)
	}

	// Check if categories exist
	categories, err := s.storage.GetCategories()
	if err != nil {
		return errors.StorageReadFailed("categories", err)
	}

	categoryMap := make(map[string]bool)
	for _, category := range categories {
		categoryMap[category.Code] = true
	}

	for _, categoryCode := range transaction.Categories {
		if !categoryMap[categoryCode] {
			return errors.CategoryNotFound(categoryCode)
		}
	}

	// Check if tags exist
	tags, err := s.storage.GetTags()
	if err != nil {
		return errors.StorageReadFailed("tags", err)
	}

	tagMap := make(map[string]bool)
	for _, tag := range tags {
		tagMap[tag.Code] = true
	}

	for _, tagCode := range transaction.Tags {
		if !tagMap[tagCode] {
			return errors.TagNotFound(tagCode)
		}
	}

	return nil
}

// EditTransaction edits a transaction by creating a new one and soft-deleting the old one
func (s *TransactionService) EditTransaction(transactionID string, modifications domain.Transaction, message string) (*domain.Transaction, error) {
	// Get all transactions
	transactions, err := s.storage.GetTransactions()
	if err != nil {
		return nil, errors.StorageReadFailed("transactions", err)
	}

	// Find the transaction to edit
	oldTransaction, err := s.findTransactionByID(transactions, transactionID)
	if err != nil {
		return nil, err
	}

	// Create new transaction by merging old with modifications
	newTransaction := domain.Transaction{
		ID:          modifications.ID, // Should be generated by caller
		Account:     oldTransaction.Account,
		Date:        oldTransaction.Date,
		Amount:      oldTransaction.Amount,
		Description: oldTransaction.Description,
		Categories:  oldTransaction.Categories,
		Tags:        oldTransaction.Tags,
		IsActive:    true,
		ParentID:    oldTransaction.ID,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}

	// Apply modifications
	if modifications.Account != "" {
		newTransaction.Account = modifications.Account
	}
	if !modifications.Date.IsZero() {
		newTransaction.Date = modifications.Date
	}
	if modifications.Amount != 0 {
		newTransaction.Amount = modifications.Amount
	}
	if modifications.Description != "" {
		newTransaction.Description = modifications.Description
	}
	if len(modifications.Categories) > 0 {
		newTransaction.Categories = modifications.Categories
	}
	if len(modifications.Tags) > 0 {
		newTransaction.Tags = modifications.Tags
	}

	// Validate the new transaction
	if err := s.validateTransaction(newTransaction); err != nil {
		return nil, errors.Wrap(errors.ErrorTypeValidation, "validation_failed", "Validation failed for edited transaction", err)
	}

	// Soft delete the old transaction with comment
	for i, txn := range transactions {
		if txn.ID == oldTransaction.ID {
			transactions[i].IsActive = false
			transactions[i].EditComment = message
			transactions[i].UpdatedAt = time.Now()
			break
		}
	}

	// Add the new transaction
	transactions = append(transactions, newTransaction)

	// Save back to storage
	if err := s.storage.SaveTransactions(transactions); err != nil {
		return nil, errors.StorageWriteFailed("transactions", err)
	}

	return &newTransaction, nil
}

// DeleteTransaction soft-deletes a transaction
func (s *TransactionService) DeleteTransaction(transactionID string, message string) error {
	// Get all transactions
	transactions, err := s.storage.GetTransactions()
	if err != nil {
		return errors.StorageReadFailed("transactions", err)
	}

	// Find the transaction to delete
	targetTransaction, err := s.findTransactionByID(transactions, transactionID)
	if err != nil {
		return err
	}

	// Check if transaction is already deleted
	if !targetTransaction.IsActive {
		return errors.TransactionAlreadyDeleted(targetTransaction.ID)
	}

	// Soft delete with comment
	for i, txn := range transactions {
		if txn.ID == targetTransaction.ID {
			transactions[i].IsActive = false
			transactions[i].EditComment = message
			transactions[i].UpdatedAt = time.Now()
			break
		}
	}

	// Save back to storage
	if err := s.storage.SaveTransactions(transactions); err != nil {
		return errors.StorageWriteFailed("transactions", err)
	}

	return nil
}

// UndoTransaction undoes the last operation on a transaction
func (s *TransactionService) UndoTransaction(transactionID string) error {
	// Get all transactions
	transactions, err := s.storage.GetTransactions()
	if err != nil {
		return errors.StorageReadFailed("transactions", err)
	}

	// Find the target transaction
	targetTransaction, err := s.findTransactionByID(transactions, transactionID)
	if err != nil {
		return err
	}

	// Determine operation type to undo
	if targetTransaction.ParentID != "" {
		// This is a transaction created by edit -> undo edit
		return s.undoEdit(transactions, targetTransaction)
	} else if !targetTransaction.IsActive && targetTransaction.EditComment != "" {
		// This is a deleted transaction -> undo delete
		return s.undoDelete(transactions, targetTransaction)
	} else if targetTransaction.IsActive && targetTransaction.EditComment == "" {
		// This is an added transaction -> undo add
		return s.undoAdd(transactions, targetTransaction)
	} else {
		return errors.InvalidOperation(targetTransaction.ID)
	}
}

// MigrateTransactionIDs migrates old transaction IDs to new format
func (s *TransactionService) MigrateTransactionIDs(generateID func() string) error {
	transactions, err := s.storage.GetTransactions()
	if err != nil {
		return errors.StorageReadFailed("transactions", err)
	}

	var updated bool
	for i, txn := range transactions {
		// Check if ID is not 11 characters (migrate to new 11-char format)
		if len(txn.ID) != 11 {
			// Generate new short UUID with 11 characters
			transactions[i].ID = generateID()
			updated = true
		}
	}

	if !updated {
		return nil // No transactions need migration
	}

	// Save updated transactions
	if err := s.storage.SaveTransactions(transactions); err != nil {
		return errors.StorageWriteFailed("transactions", err)
	}

	return nil
}

// Helper methods

// findTransactionByID finds a transaction by ID (supports partial IDs)
func (s *TransactionService) findTransactionByID(transactions []domain.Transaction, id string) (*domain.Transaction, error) {
	var matches []domain.Transaction

	for _, txn := range transactions {
		if strings.HasPrefix(txn.ID, id) {
			matches = append(matches, txn)
		}
	}

	if len(matches) == 0 {
		return nil, errors.TransactionNotFound(id)
	}

	if len(matches) > 1 {
		return nil, errors.AmbiguousID(id)
	}

	return &matches[0], nil
}

func (s *TransactionService) undoEdit(transactions []domain.Transaction, childTransaction *domain.Transaction) error {
	// Find the parent transaction
	var parentTransaction *domain.Transaction
	for _, txn := range transactions {
		if txn.ID == childTransaction.ParentID {
			parentTransaction = &txn
			break
		}
	}

	if parentTransaction == nil {
		return errors.ParentNotFound(childTransaction.ParentID)
	}

	// Reactivate parent transaction and completely remove child transaction
	var updatedTransactions []domain.Transaction
	for _, txn := range transactions {
		if txn.ID == parentTransaction.ID {
			// Reactivate parent transaction
			txn.IsActive = true
			txn.EditComment = ""
			txn.UpdatedAt = time.Now()
			updatedTransactions = append(updatedTransactions, txn)
		} else if txn.ID != childTransaction.ID {
			// Keep all other transactions (except child)
			updatedTransactions = append(updatedTransactions, txn)
		}
		// Child transaction is completely removed (not added to updatedTransactions)
	}

	// Save back to storage
	if err := s.storage.SaveTransactions(updatedTransactions); err != nil {
		return errors.StorageWriteFailed("transactions", err)
	}

	return nil
}

func (s *TransactionService) undoDelete(transactions []domain.Transaction, deletedTransaction *domain.Transaction) error {
	// Set is_active to true and remove comment
	for i, txn := range transactions {
		if txn.ID == deletedTransaction.ID {
			transactions[i].IsActive = true
			transactions[i].EditComment = ""
			transactions[i].UpdatedAt = time.Now()
			break
		}
	}

	// Save back to storage
	if err := s.storage.SaveTransactions(transactions); err != nil {
		return errors.StorageWriteFailed("transactions", err)
	}

	return nil
}

func (s *TransactionService) undoAdd(transactions []domain.Transaction, addedTransaction *domain.Transaction) error {
	// Set is_active to false with comment
	for i, txn := range transactions {
		if txn.ID == addedTransaction.ID {
			transactions[i].IsActive = false
			transactions[i].EditComment = "Undo add operation"
			transactions[i].UpdatedAt = time.Now()
			break
		}
	}

	// Save back to storage
	if err := s.storage.SaveTransactions(transactions); err != nil {
		return errors.StorageWriteFailed("transactions", err)
	}

	return nil
}
